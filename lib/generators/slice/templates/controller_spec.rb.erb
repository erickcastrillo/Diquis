# frozen_string_literal: true

require "rails_helper"

# <%= full_model_name.pluralize %>Controller Specs
# 
# Tests for the HTTP request handling layer for <%= model_name.humanize.pluralize.downcase %>.
# Covers all CRUD operations, Inertia.js rendering, and authorization.
# 
<% if module_name -%>
module <%= module_name %>
  RSpec.describe <%= model_name.camelize.pluralize %>Controller, type: :controller do
<% else -%>
module <%= slice_name.camelize %>
  RSpec.describe <%= model_name.camelize.pluralize %>Controller, type: :controller do
<% end -%>
<% unless skip_academy? -%>
    # Test setup with authentication and academy context
    let(:user) { create(:user) }
    let(:academy) { create(:academy) }
    let!(:<%= model_name.underscore %>) { create(:<%= model_name.underscore %>, academy: academy) }

    before do
      # Mock authentication (adjust based on your auth setup)
      allow(controller).to receive(:current_user).and_return(user)
      allow(user).to receive(:academies).and_return(Academy.where(id: academy.id))
      allow(user).to receive(:default_academy).and_return(academy)
    end
<% else -%>
    # Test setup for foundation model controller
    let(:user) { create(:user) }
    let!(:<%= model_name.underscore %>) { create(:<%= model_name.underscore %>) }

    before do
      # Mock authentication (adjust based on your auth setup)
      allow(controller).to receive(:current_user).and_return(user)
    end
<% end -%>

    # Test index action
    describe "GET #index" do
      let!(:<%= model_name.underscore.pluralize %>) { create_list(:<%= model_name.underscore %>, 3<% unless skip_academy? %>, academy: academy<% end %>) }

      it "returns a successful response" do
        get :index<% unless skip_academy? %>, params: { academy_slug: academy.slug }<% end %>
        expect(response).to have_http_status(:success)
      end

      it "renders the Index component via Inertia" do
        expect(controller).to receive(:render).with(
          hash_including(inertia: "<%= model_name.camelize %>/Index")
        )
        get :index<% unless skip_academy? %>, params: { academy_slug: academy.slug }<% end %>
      end

      it "provides <%= model_name.humanize.pluralize.downcase %> data to the component" do
        get :index<% unless skip_academy? %>, params: { academy_slug: academy.slug }<% end %>
        rendered_props = controller.instance_variable_get(:@_inertia_props)
        expect(rendered_props[:<%= model_name.underscore.pluralize %>]).to be_present
      end

<% unless skip_academy? -%>
      it "includes academy context in props" do
        get :index, params: { academy_slug: academy.slug }
        rendered_props = controller.instance_variable_get(:@_inertia_props)
        expect(rendered_props[:academy]).to include(
          slug: academy.slug,
          name: academy.name
        )
      end

      context "with different academy" do
        let(:other_academy) { create(:academy) }
        let!(:<%= model_name.underscore.pluralize %>_other) { create_list(:<%= model_name.underscore %>, 2, academy: other_academy) }

        it "only shows <%= model_name.humanize.pluralize.downcase %> from current academy" do
          allow(user).to receive(:academies).and_return(Academy.where(id: other_academy.id))
          get :index, params: { academy_slug: other_academy.slug }
          
          rendered_props = controller.instance_variable_get(:@_inertia_props)
          expect(rendered_props[:<%= model_name.underscore.pluralize %>].size).to eq(2)
        end
      end
<% end -%>
    end

    # Test show action
    describe "GET #show" do
      it "returns a successful response" do
        get :show, params: { id: <%= model_name.underscore %>.id<% unless skip_academy? %>, academy_slug: academy.slug<% end %> }
        expect(response).to have_http_status(:success)
      end

      it "renders the Show component via Inertia" do
        expect(controller).to receive(:render).with(
          hash_including(inertia: "<%= model_name.camelize %>/Show")
        )
        get :show, params: { id: <%= model_name.underscore %>.id<% unless skip_academy? %>, academy_slug: academy.slug<% end %> }
      end

      it "provides the <%= model_name.humanize.downcase %> data to the component" do
        get :show, params: { id: <%= model_name.underscore %>.id<% unless skip_academy? %>, academy_slug: academy.slug<% end %> }
        rendered_props = controller.instance_variable_get(:@_inertia_props)
        expect(rendered_props[:<%= model_name.underscore %>]).to be_present
      end

      context "with non-existent <%= model_name.humanize.downcase %>" do
        it "redirects with an error message" do
          get :show, params: { id: "non-existent"<% unless skip_academy? %>, academy_slug: academy.slug<% end %> }
          expect(response).to redirect_to(<%= model_name.underscore.pluralize %>_path)
          expect(flash[:alert]).to be_present
        end
      end
    end

    # Test new action
    describe "GET #new" do
      it "returns a successful response" do
        get :new<% unless skip_academy? %>, params: { academy_slug: academy.slug }<% end %>
        expect(response).to have_http_status(:success)
      end

      it "renders the New component via Inertia" do
        expect(controller).to receive(:render).with(
          hash_including(inertia: "<%= model_name.camelize %>/New")
        )
        get :new<% unless skip_academy? %>, params: { academy_slug: academy.slug }<% end %>
      end

      it "provides a new <%= model_name.humanize.downcase %> instance to the component" do
        get :new<% unless skip_academy? %>, params: { academy_slug: academy.slug }<% end %>
        rendered_props = controller.instance_variable_get(:@_inertia_props)
        expect(rendered_props[:<%= model_name.underscore %>]).to be_present
      end
    end

    # Test create action
    describe "POST #create" do
      let(:valid_attributes) do
        {
<% attributes.each_with_index do |attr, index| -%>
<% if attr[:name] == 'name' -%>
          name: "Test <%= model_name.humanize %>"<%= index < attributes.length - 1 ? ',' : '' %>
<% elsif attr[:type] == 'boolean' -%>
          <%= attr[:name] %>: true<%= index < attributes.length - 1 ? ',' : '' %>
<% elsif attr[:type] == 'text' -%>
          <%= attr[:name] %>: "Test <%= attr[:name].humanize.downcase %> description"<%= index < attributes.length - 1 ? ',' : '' %>
<% elsif attr[:type] == 'string' -%>
          <%= attr[:name] %>: "Test <%= attr[:name].humanize.downcase %>"<%= index < attributes.length - 1 ? ',' : '' %>
<% else -%>
          <%= attr[:name] %>: "test_value"<%= index < attributes.length - 1 ? ',' : '' %>
<% end -%>
<% end -%>
        }
      end

      context "with valid parameters" do
        it "creates a new <%= model_name.humanize.downcase %>" do
          expect {
            post :create, params: { 
              <%= model_name.underscore %>: valid_attributes<% unless skip_academy? %>,
              academy_slug: academy.slug<% end %>
            }
          }.to change(<%= full_model_name %>, :count).by(1)
        end

        it "redirects to the created <%= model_name.humanize.downcase %>" do
          post :create, params: { 
            <%= model_name.underscore %>: valid_attributes<% unless skip_academy? %>,
            academy_slug: academy.slug<% end %>
          }
          expect(response).to redirect_to(<%= model_name.underscore %>_path(<%= full_model_name %>.last))
          expect(flash[:notice]).to eq("<%= model_name.humanize %> was successfully created.")
        end
      end

      context "with invalid parameters" do
        let(:invalid_attributes) do
          {
<% attributes.each_with_index do |attr, index| -%>
<% if attr[:name] == 'name' -%>
            name: ""<%= index < attributes.length - 1 ? ',' : '' %>
<% elsif attr[:type] == 'string' -%>
            <%= attr[:name] %>: ""<%= index < attributes.length - 1 ? ',' : '' %>
<% else -%>
            <%= attr[:name] %>: nil<%= index < attributes.length - 1 ? ',' : '' %>
<% end -%>
<% end -%>
          }
        end

        it "does not create a new <%= model_name.humanize.downcase %>" do
          expect {
            post :create, params: { 
              <%= model_name.underscore %>: invalid_attributes<% unless skip_academy? %>,
              academy_slug: academy.slug<% end %>
            }
          }.not_to change(<%= full_model_name %>, :count)
        end

        it "redirects back to new with errors" do
          post :create, params: { 
            <%= model_name.underscore %>: invalid_attributes<% unless skip_academy? %>,
            academy_slug: academy.slug<% end %>
          }
          expect(response).to redirect_to(new_<%= model_name.underscore %>_path)
        end
      end
    end

    # Test edit action
    describe "GET #edit" do
      it "returns a successful response" do
        get :edit, params: { id: <%= model_name.underscore %>.id<% unless skip_academy? %>, academy_slug: academy.slug<% end %> }
        expect(response).to have_http_status(:success)
      end

      it "renders the Edit component via Inertia" do
        expect(controller).to receive(:render).with(
          hash_including(inertia: "<%= model_name.camelize %>/Edit")
        )
        get :edit, params: { id: <%= model_name.underscore %>.id<% unless skip_academy? %>, academy_slug: academy.slug<% end %> }
      end
    end

    # Test update action
    describe "PATCH #update" do
      let(:new_attributes) do
        {
<% attributes.each_with_index do |attr, index| -%>
<% if attr[:name] == 'name' -%>
          name: "Updated <%= model_name.humanize %>"<%= index < attributes.length - 1 ? ',' : '' %>
<% elsif attr[:type] == 'boolean' -%>
          <%= attr[:name] %>: false<%= index < attributes.length - 1 ? ',' : '' %>
<% elsif attr[:type] == 'text' -%>
          <%= attr[:name] %>: "Updated <%= attr[:name].humanize.downcase %>"<%= index < attributes.length - 1 ? ',' : '' %>
<% elsif attr[:type] == 'string' -%>
          <%= attr[:name] %>: "Updated <%= attr[:name].humanize.downcase %>"<%= index < attributes.length - 1 ? ',' : '' %>
<% else -%>
          <%= attr[:name] %>: "updated_value"<%= index < attributes.length - 1 ? ',' : '' %>
<% end -%>
<% end -%>
        }
      end

      context "with valid parameters" do
        it "updates the <%= model_name.humanize.downcase %>" do
          patch :update, params: { 
            id: <%= model_name.underscore %>.id, 
            <%= model_name.underscore %>: new_attributes<% unless skip_academy? %>,
            academy_slug: academy.slug<% end %>
          }
          <%= model_name.underscore %>.reload
<% attributes.each do |attr| -%>
<% if attr[:name] == 'name' -%>
          expect(<%= model_name.underscore %>.name).to eq("Updated <%= model_name.humanize %>")
<% end -%>
<% end -%>
        end

        it "redirects to the <%= model_name.humanize.downcase %>" do
          patch :update, params: { 
            id: <%= model_name.underscore %>.id, 
            <%= model_name.underscore %>: new_attributes<% unless skip_academy? %>,
            academy_slug: academy.slug<% end %>
          }
          expect(response).to redirect_to(<%= model_name.underscore %>)
          expect(flash[:notice]).to eq("<%= model_name.humanize %> was successfully updated.")
        end
      end

      context "with invalid parameters" do
        let(:invalid_attributes) do
          {
<% attributes.each_with_index do |attr, index| -%>
<% if attr[:name] == 'name' -%>
            name: ""<%= index < attributes.length - 1 ? ',' : '' %>
<% elsif attr[:type] == 'string' -%>
            <%= attr[:name] %>: ""<%= index < attributes.length - 1 ? ',' : '' %>
<% else -%>
            <%= attr[:name] %>: <%= model_name.underscore %>.<%= attr[:name] %><%= index < attributes.length - 1 ? ',' : '' %>
<% end -%>
<% end -%>
          }
        end

        it "redirects back to edit with errors" do
          patch :update, params: { 
            id: <%= model_name.underscore %>.id, 
            <%= model_name.underscore %>: invalid_attributes<% unless skip_academy? %>,
            academy_slug: academy.slug<% end %>
          }
          expect(response).to redirect_to(edit_<%= model_name.underscore %>_path(<%= model_name.underscore %>))
        end
      end
    end

    # Test destroy action
    describe "DELETE #destroy" do
      it "destroys the <%= model_name.humanize.downcase %>" do
        expect {
          delete :destroy, params: { id: <%= model_name.underscore %>.id<% unless skip_academy? %>, academy_slug: academy.slug<% end %> }
        }.to change(<%= full_model_name %>, :count).by(-1)
      end

      it "redirects to the <%= model_name.humanize.pluralize.downcase %> list" do
        delete :destroy, params: { id: <%= model_name.underscore %>.id<% unless skip_academy? %>, academy_slug: academy.slug<% end %> }
        expect(response).to redirect_to(<%= model_name.underscore.pluralize %>_path)
        expect(flash[:notice]).to eq("<%= model_name.humanize %> was successfully deleted.")
      end
    end

    # Test before_action callbacks
    describe "before_action callbacks" do
      describe "#set_<%= model_name.underscore %>" do
        it "loads the <%= model_name.humanize.downcase %> for show action" do
          get :show, params: { id: <%= model_name.underscore %>.id<% unless skip_academy? %>, academy_slug: academy.slug<% end %> }
          expect(controller.instance_variable_get(:@<%= model_name.underscore %>)).to eq(<%= model_name.underscore %>)
        end

        it "loads the <%= model_name.humanize.downcase %> for edit action" do
          get :edit, params: { id: <%= model_name.underscore %>.id<% unless skip_academy? %>, academy_slug: academy.slug<% end %> }
          expect(controller.instance_variable_get(:@<%= model_name.underscore %>)).to eq(<%= model_name.underscore %>)
        end
      end

<% unless skip_academy? -%>
      describe "#set_academy" do
        it "loads the academy for all actions" do
          get :index, params: { academy_slug: academy.slug }
          expect(controller.instance_variable_get(:@academy)).to eq(academy)
        end

        it "uses default academy when no slug provided" do
          get :index
          expect(controller.instance_variable_get(:@academy)).to eq(academy)
        end
      end
<% end -%>
    end

    # Test error handling
    describe "error handling" do
      context "when service returns error" do
        before do
          allow_any_instance_of(<%= full_model_name %>Service).to receive(:create).and_return(
            ServiceResult.new(success: false, errors: ["Something went wrong"])
          )
        end

        it "handles service errors gracefully" do
          post :create, params: { 
            <%= model_name.underscore %>: { name: "Test" }<% unless skip_academy? %>,
            academy_slug: academy.slug<% end %>
          }
          expect(response).to redirect_to(new_<%= model_name.underscore %>_path)
        end
      end
    end
  end
end