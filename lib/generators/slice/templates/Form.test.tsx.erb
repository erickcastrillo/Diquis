/**
 * <%= model_name.camelize %> Form Component Tests
 * 
 * Tests for the <%= model_name.humanize.downcase %> form component including:
 * - Form rendering and field types
 * - Form state management and validation
 * - Form submission (create and update modes)
 * - Error handling and display
 * - Accessibility and user interactions
 */

import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import Form from '../Form'
import { <%= model_name.camelize %>Type } from '../types'

// Mock Inertia.js
const mockPost = vi.fn()
const mockPut = vi.fn()

vi.mock('@inertiajs/react', async () => {
  const actual = await vi.importActual('@inertiajs/react')
  return {
    ...actual,
    useForm: () => ({
      data: {
<% attributes.each do |attr| -%>
<% if attr[:name] == 'name' -%>
        name: '',
<% elsif attr[:type] == 'boolean' -%>
        <%= attr[:name] %>: false,
<% else -%>
        <%= attr[:name] %>: '',
<% end -%>
<% end -%>
      },
      setData: vi.fn(),
      post: mockPost,
      put: mockPut,
      processing: false,
      errors: {},
      reset: vi.fn()
    })
  }
})

// Test data
const mockAcademy = {
  slug: 'test-academy',
  name: 'Test Academy'
}

const new<%= model_name.camelize %>: <%= model_name.camelize %>Type = {
  id: '',
  slug: '',
<% attributes.each do |attr| -%>
<% if attr[:name] == 'name' -%>
  name: '',
<% elsif attr[:type] == 'boolean' -%>
  <%= attr[:name] %>: false,
<% elsif attr[:type] == 'integer' -%>
  <%= attr[:name] %>: 0,
<% else -%>
  <%= attr[:name] %>: '',
<% end -%>
<% end -%>
  created_at: '',
  updated_at: ''
}

const existing<%= model_name.camelize %>: <%= model_name.camelize %>Type = {
  id: 'existing-id',
  slug: 'existing-<%= model_name.underscore %>',
<% attributes.each do |attr| -%>
<% if attr[:name] == 'name' -%>
  name: 'Existing <%= model_name.humanize %>',
<% elsif attr[:type] == 'boolean' -%>
  <%= attr[:name] %>: true,
<% elsif attr[:type] == 'text' -%>
  <%= attr[:name] %>: 'Existing <%= attr[:name].humanize.downcase %> content',
<% elsif attr[:type] == 'string' -%>
  <%= attr[:name] %>: 'Existing <%= attr[:name].humanize.downcase %>',
<% elsif attr[:type] == 'integer' -%>
  <%= attr[:name] %>: 100,
<% else -%>
  <%= attr[:name] %>: 'existing_value',
<% end -%>
<% end -%>
  created_at: '2024-01-01T00:00:00Z',
  updated_at: '2024-01-01T00:00:00Z'
}

describe('<%= model_name.camelize %> Form', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  // Test form rendering in create mode
  describe('create mode rendering', () => {
    it('renders all form fields', () => {
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
<% attributes.each do |attr| -%>
<% if attr[:type] == 'text' -%>
      expect(screen.getByLabelText('<%= attr[:name].humanize %>')).toBeInTheDocument()
      expect(screen.getByRole('textbox', { name: '<%= attr[:name].humanize %>' })).toBeInTheDocument()
<% elsif attr[:type] == 'boolean' -%>
      expect(screen.getByLabelText('<%= attr[:name].humanize %>')).toBeInTheDocument()
      expect(screen.getByRole('checkbox', { name: '<%= attr[:name].humanize %>' })).toBeInTheDocument()
<% else -%>
      expect(screen.getByLabelText('<%= attr[:name].humanize %>')).toBeInTheDocument()
      expect(screen.getByDisplayValue('')).toBeInTheDocument()
<% end -%>
<% end -%>
    })

<% attributes.each do |attr| -%>
<% if attr[:type] == 'text' -%>
    it('renders <%= attr[:name] %> as textarea', () => {
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
      const <%= attr[:name] %>Field = screen.getByLabelText('<%= attr[:name].humanize %>')
      expect(<%= attr[:name] %>Field.tagName).toBe('TEXTAREA')
      expect(<%= attr[:name] %>Field).toHaveAttribute('rows', '4')
      expect(<%= attr[:name] %>Field).toHaveAttribute('placeholder', 'Enter <%= attr[:name].humanize.downcase %>')
    })

<% elsif attr[:type] == 'boolean' -%>
    it('renders <%= attr[:name] %> as checkbox', () => {
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
      const <%= attr[:name] %>Field = screen.getByRole('checkbox', { name: '<%= attr[:name].humanize %>' })
      expect(<%= attr[:name] %>Field).toHaveAttribute('type', 'checkbox')
      expect(<%= attr[:name] %>Field).not.toBeChecked()
    })

<% else -%>
    it('renders <%= attr[:name] %> as text input', () => {
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
      const <%= attr[:name] %>Field = screen.getByLabelText('<%= attr[:name].humanize %>')
      expect(<%= attr[:name] %>Field).toHaveAttribute('type', 'text')
      expect(<%= attr[:name] %>Field).toHaveAttribute('placeholder', 'Enter <%= attr[:name].humanize.downcase %>')
    })

<% end -%>
<% end -%>
    it('displays create button text', () => {
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
      expect(screen.getByRole('button', { name: 'Create <%= model_name.humanize %>' })).toBeInTheDocument()
    })

    it('shows cancel button', () => {
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
      expect(screen.getByRole('button', { name: 'Cancel' })).toBeInTheDocument()
    })
  })

  // Test form rendering in edit mode
  describe('edit mode rendering', () => {
    it('pre-fills form with existing data', () => {
      render(<Form <%= model_name.underscore %>={existing<%= model_name.camelize %>} academy={mockAcademy} isEditing={true} />)
      
<% attributes.each do |attr| -%>
<% if attr[:name] == 'name' -%>
      expect(screen.getByDisplayValue('Existing <%= model_name.humanize %>')).toBeInTheDocument()
<% elsif attr[:type] == 'boolean' -%>
      const <%= attr[:name] %>Checkbox = screen.getByRole('checkbox', { name: '<%= attr[:name].humanize %>' })
      expect(<%= attr[:name] %>Checkbox).toBeChecked()
<% elsif attr[:type] == 'text' -%>
      expect(screen.getByDisplayValue('Existing <%= attr[:name].humanize.downcase %> content')).toBeInTheDocument()
<% elsif attr[:type] == 'string' -%>
      expect(screen.getByDisplayValue('Existing <%= attr[:name].humanize.downcase %>')).toBeInTheDocument()
<% elsif attr[:type] == 'integer' -%>
      expect(screen.getByDisplayValue('100')).toBeInTheDocument()
<% else -%>
      expect(screen.getByDisplayValue('existing_value')).toBeInTheDocument()
<% end -%>
<% end -%>
    })

    it('displays update button text', () => {
      render(<Form <%= model_name.underscore %>={existing<%= model_name.camelize %>} academy={mockAcademy} isEditing={true} />)
      
      expect(screen.getByRole('button', { name: 'Update <%= model_name.humanize %>' })).toBeInTheDocument()
    })
  })

  // Test form interactions and state management
  describe('form interactions', () => {
    it('handles text input changes', async () => {
      const user = userEvent.setup()
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
<% name_attr = attributes.find { |attr| attr[:name] == 'name' } -%>
<% if name_attr -%>
      const nameInput = screen.getByLabelText('Name')
      await user.type(nameInput, 'New <%= model_name.humanize %>')
      
      expect(nameInput).toHaveValue('New <%= model_name.humanize %>')
<% else -%>
<% first_string_attr = attributes.find { |attr| attr[:type] == 'string' } -%>
<% if first_string_attr -%>
      const input = screen.getByLabelText('<%= first_string_attr[:name].humanize %>')
      await user.type(input, 'Test value')
      
      expect(input).toHaveValue('Test value')
<% end -%>
<% end -%>
    })

<% if attributes.any? { |attr| attr[:type] == 'text' } -%>
<% textarea_attr = attributes.find { |attr| attr[:type] == 'text' } -%>
    it('handles textarea input changes', async () => {
      const user = userEvent.setup()
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
      const textareaInput = screen.getByLabelText('<%= textarea_attr[:name].humanize %>')
      await user.type(textareaInput, 'Multi-line\ncontent here')
      
      expect(textareaInput).toHaveValue('Multi-line\ncontent here')
    })

<% end -%>
<% if attributes.any? { |attr| attr[:type] == 'boolean' } -%>
<% checkbox_attr = attributes.find { |attr| attr[:type] == 'boolean' } -%>
    it('handles checkbox changes', async () => {
      const user = userEvent.setup()
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
      const checkbox = screen.getByRole('checkbox', { name: '<%= checkbox_attr[:name].humanize %>' })
      expect(checkbox).not.toBeChecked()
      
      await user.click(checkbox)
      expect(checkbox).toBeChecked()
      
      await user.click(checkbox)
      expect(checkbox).not.toBeChecked()
    })

<% end -%>
    it('calls window.history.back() when cancel is clicked', async () => {
      const user = userEvent.setup()
      const mockBack = vi.fn()
      vi.stubGlobal('window', { history: { back: mockBack } })
      
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
      const cancelButton = screen.getByRole('button', { name: 'Cancel' })
      await user.click(cancelButton)
      
      expect(mockBack).toHaveBeenCalled()
    })
  })

  // Test form submission
  describe('form submission', () => {
    it('submits form for creation', async () => {
      const user = userEvent.setup()
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
      const submitButton = screen.getByRole('button', { name: 'Create <%= model_name.humanize %>' })
      await user.click(submitButton)
      
      expect(mockPost).toHaveBeenCalledWith('/<%= model_name.underscore.pluralize %>')
    })

    it('submits form for update', async () => {
      const user = userEvent.setup()
      render(<Form <%= model_name.underscore %>={existing<%= model_name.camelize %>} academy={mockAcademy} isEditing={true} />)
      
      const submitButton = screen.getByRole('button', { name: 'Update <%= model_name.humanize %>' })
      await user.click(submitButton)
      
      expect(mockPut).toHaveBeenCalledWith('/<%= model_name.underscore.pluralize %>/existing-id')
    })

    it('prevents default form submission', async () => {
      const user = userEvent.setup()
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
      const form = screen.getByRole('form') || screen.getByTestId('form') || document.querySelector('form')
      const submitEvent = new Event('submit', { bubbles: true, cancelable: true })
      const preventDefaultSpy = vi.spyOn(submitEvent, 'preventDefault')
      
      if (form) {
        fireEvent(form, submitEvent)
        expect(preventDefaultSpy).toHaveBeenCalled()
      }
    })
  })

  // Test processing state
  describe('processing state', () => {
    it('shows loading text when processing', () => {
      // Mock processing state
      vi.mocked(require('@inertiajs/react').useForm).mockReturnValue({
        data: { name: '', description: '' },
        setData: vi.fn(),
        post: mockPost,
        put: mockPut,
        processing: true,
        errors: {},
        reset: vi.fn()
      })

      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
      expect(screen.getByRole('button', { name: 'Saving...' })).toBeInTheDocument()
      expect(screen.getByRole('button', { name: 'Saving...' })).toBeDisabled()
    })

    it('disables submit button when processing', () => {
      // Mock processing state
      vi.mocked(require('@inertiajs/react').useForm).mockReturnValue({
        data: { name: '', description: '' },
        setData: vi.fn(),
        post: mockPost,
        put: mockPut,
        processing: true,
        errors: {},
        reset: vi.fn()
      })

      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
      const submitButton = screen.getByRole('button', { name: 'Saving...' })
      expect(submitButton).toHaveAttribute('disabled')
    })
  })

  // Test error handling
  describe('error handling', () => {
    it('displays validation errors', () => {
      const mockErrors = {
<% attributes.each_with_index do |attr, index| -%>
        <%= attr[:name] %>: '<%= attr[:name].humanize %> is required'<%= index < attributes.length - 1 ? ',' : '' %>
<% end -%>
      }

      vi.mocked(require('@inertiajs/react').useForm).mockReturnValue({
        data: { name: '', description: '' },
        setData: vi.fn(),
        post: mockPost,
        put: mockPut,
        processing: false,
        errors: mockErrors,
        reset: vi.fn()
      })

      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
<% attributes.each do |attr| -%>
      expect(screen.getByText('<%= attr[:name].humanize %> is required')).toBeInTheDocument()
<% end -%>
    })

    it('applies error styling to fields with errors', () => {
      const mockErrors = { name: 'Name is required' }

      vi.mocked(require('@inertiajs/react').useForm).mockReturnValue({
        data: { name: '', description: '' },
        setData: vi.fn(),
        post: mockPost,
        put: mockPut,
        processing: false,
        errors: mockErrors,
        reset: vi.fn()
      })

      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
      const errorMessage = screen.getByText('Name is required')
      expect(errorMessage).toHaveClass('text-red-600')
    })
  })

  // Test accessibility
  describe('accessibility', () => {
    it('associates labels with form controls', () => {
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
<% attributes.each do |attr| -%>
      const <%= attr[:name] %>Label = screen.getByText('<%= attr[:name].humanize %>')
      const <%= attr[:name] %>Input = screen.getByLabelText('<%= attr[:name].humanize %>')
      
      expect(<%= attr[:name] %>Label).toHaveAttribute('for', '<%= attr[:name] %>')
      expect(<%= attr[:name] %>Input).toHaveAttribute('id', '<%= attr[:name] %>')
<% end -%>
    })

    it('provides proper ARIA attributes for required fields', () => {
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
<% required_attrs = attributes.select { |attr| attr[:name] == 'name' || attr[:type] == 'string' } -%>
<% required_attrs.each do |attr| -%>
      const <%= attr[:name] %>Input = screen.getByLabelText('<%= attr[:name].humanize %>')
      expect(<%= attr[:name] %>Input).toHaveAttribute('required')
<% end -%>
    })

    it('has proper focus management', async () => {
      const user = userEvent.setup()
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
      const firstInput = screen.getAllByRole('textbox')[0] || screen.getAllByRole('checkbox')[0]
      await user.tab()
      
      expect(document.activeElement).toBe(firstInput)
    })

    it('maintains proper color contrast for buttons', () => {
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
      const submitButton = screen.getByRole('button', { name: 'Create <%= model_name.humanize %>' })
      const cancelButton = screen.getByRole('button', { name: 'Cancel' })
      
      expect(submitButton).toHaveClass('text-white', 'bg-blue-600')
      expect(cancelButton).toHaveClass('text-gray-700', 'bg-white')
    })
  })

  // Test responsive behavior
  describe('responsive design', () => {
    it('applies responsive spacing classes', () => {
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
      const form = document.querySelector('form')
      expect(form).toHaveClass('space-y-6')
    })

    it('uses full width inputs', () => {
      render(<Form <%= model_name.underscore %>={new<%= model_name.camelize %>} academy={mockAcademy} isEditing={false} />)
      
<% attributes.each do |attr| -%>
<% if attr[:type] != 'boolean' -%>
      const <%= attr[:name] %>Input = screen.getByLabelText('<%= attr[:name].humanize %>')
      expect(<%= attr[:name] %>Input).toHaveClass('w-full')
<% end -%>
<% end -%>
    })
  })
})